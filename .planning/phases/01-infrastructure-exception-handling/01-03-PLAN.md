---
phase: 01-infrastructure-exception-handling
plan: "03"
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - aadap/services/execution.py
  - aadap/agents/adapters/databricks_adapter.py
  - aadap/agents/adapters/fabric_adapter.py
  - aadap/agents/base.py
autonomous: true
requirements:
  - EXCPT-03
  - EXCPT-04
  - EXCPT-05
  - EXCPT-06
must_haves:
  truths:
    - "execution.py catches specific exception types with proper logging"
    - "Agent adapter pass statements have debug logging explaining the fallback"
    - "base.py register_tools no-op is documented as intentional"
    - "Error context (task_id, error_code) preserved in all error handlers"
  artifacts:
    - path: "aadap/services/execution.py"
      provides: "Execution service with proper exception handling"
      contains: "from aadap.core.exceptions import"
    - path: "aadap/agents/adapters/databricks_adapter.py"
      provides: "Databricks adapter with logged fallback"
      contains: "logger.debug"
    - path: "aadap/agents/adapters/fabric_adapter.py"
      provides: "Fabric adapter with logged fallback"
      contains: "logger.debug"
    - path: "aadap/agents/base.py"
      provides: "Base agent with documented no-op"
      contains: "no-op" OR "intentionally"
  key_links:
    - from: "aadap/services/execution.py"
      to: "aadap/core/exceptions.py"
      via: "from aadap.core.exceptions import"
    - from: "execution.py execute_task"
      to: "exception handler"
      via: "try/except with specific types"
---

<objective>
Replace bare `except Exception` handlers in execution.py with specific types. Add debug logging to empty `pass` statements in agent adapters and base.py to explain intentional fallbacks.

Purpose: Ensure execution service failures are traceable with meaningful context. Eliminate silent fallbacks that hide potential issues.
Output: Updated execution service and agent files with proper exception handling and logging.
</objective>

<execution_context>
@C:/Users/parth/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/parth/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/01-infrastructure-exception-handling/01-CONTEXT.md
@.planning/phases/01-infrastructure-exception-handling/01-RESEARCH.md
@.planning/phases/01-infrastructure-exception-handling/01-01-SUMMARY.md

@aadap/services/execution.py
@aadap/agents/base.py
@aadap/agents/adapters/databricks_adapter.py
@aadap/agents/adapters/fabric_adapter.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace bare except in execution.py (EXCPT-03)</name>
  <files>aadap/services/execution.py</files>
  <action>
Update `aadap/services/execution.py` to replace bare `except Exception` handlers with specific exception types.

1. Add import near top of file (around line 70):
   ```python
   from aadap.core.exceptions import (
       AADAPError,
       ExecutionError,
       OrchestratorError,
       AgentLifecycleError,
       IntegrationError,
   )
   ```

2. Fix exception handlers - search for `except Exception` patterns:

   - Line ~533-553 (execute_task main handler): This is the top-level handler for the execution flow.
     Restructure to catch specific types first:
     ```python
     except (ExecutionError, OrchestratorError, AgentLifecycleError) as exc:
         logger.error(
             "execution.error",
             task_id=str(task_id),
             error_code=exc.error_code,
             severity=exc.severity.value,
             error=str(exc),
         )
         # ... transition to CANCELLED/DEV_FAILED ...
         return {
             "task_id": str(task_id),
             "status": "FAILED",
             "error_code": exc.error_code,
             "error": str(exc),
         }
     except Exception as exc:
         logger.exception(
             "execution.unexpected_error",
             task_id=str(task_id),
             error=str(exc),
         )
         # ... existing transition logic ...
         return {
             "task_id": str(task_id),
             "status": "FAILED",
             "error": str(exc),
         }
     ```

   - Line ~547-548 (inner except in cleanup): This is best-effort cleanup. Add comment:
     ```python
     except Exception:
         logger.debug("execution.cleanup_failed", task_id=str(task_id))
         pass  # Best effort - state may already be terminal
     ```

   - Line ~1028-1041 (_execute_direct_operation): Catch specific types for platform operations:
     ```python
     except (IntegrationError, ExecutionError) as exc:
         logger.error(
             "execution.direct_error",
             task_id=str(task.id),
             error_code=exc.error_code,
             error=str(exc),
         )
     ```

   - Line ~1235-1240 (_run_optimization_phase): Already has specific handling pattern.

3. Ensure all error returns include error_code when available from AADAPError.

4. Add error_code field to returned dict where AADAPError is caught.

Preserve existing transition logic and state machine behavior.
  </action>
  <verify>
cd D:/bionics && python -c "from aadap.services.execution import ExecutionService; print('OK')"
  </verify>
  <done>
execution.py catches specific exception types (ExecutionError, OrchestratorError, AgentLifecycleError) with proper logging. Error returns include error_code. Unexpected exceptions logged with full traceback.
</done>
</task>

<task type="auto">
  <name>Task 2: Add logging to empty pass statements in agents (EXCPT-04, EXCPT-05, EXCPT-06)</name>
  <files>aadap/agents/adapters/databricks_adapter.py, aadap/agents/adapters/fabric_adapter.py, aadap/agents/base.py</files>
  <action>
Add debug logging to empty `pass` statements in exception handlers and no-op methods.

**Part A: databricks_adapter.py (EXCPT-04)**
At line ~304 in `_coerce_task_id`, the ValueError handler has empty pass:
```python
except ValueError:
    logger.debug(
        "adapter.invalid_task_id_format",
        raw_task_id=str(raw_task_id)[:36],
        fallback="generating_uuid",
    )
```
This explains why a new UUID is generated when the input is malformed.

**Part B: fabric_adapter.py (EXCPT-05)**
At line ~309 in `_coerce_task_id`, same pattern:
```python
except ValueError:
    logger.debug(
        "adapter.invalid_task_id_format",
        raw_task_id=str(raw_task_id)[:36],
        fallback="generating_uuid",
    )
```

**Part C: base.py (EXCPT-06)**
At line ~293 in `register_tools`, the default no-op should be documented:
```python
def register_tools(self) -> None:
    """
    Register tools with the agent.

    Default: no-op.  Subclasses override to register domain tools.
    This is intentionally empty - base agents have no default tools.
    """
    pass  # Intentional no-op: subclasses override to register tools
```
Or add a docstring comment explaining it's intentional. The key is making it clear this isn't a bug.

Ensure `logger` is available in adapter files (should already be imported from `aadap.core.logging`).
  </action>
  <verify>
cd D:/bionics && grep -n "pass" aadap/agents/adapters/databricks_adapter.py | grep -v "passphrase" | head -5
cd D:/bionics && grep -n "pass" aadap/agents/adapters/fabric_adapter.py | head -5
cd D:/bionics && grep -n "pass" aadap/agents/base.py | head -5
  </verify>
  <done>
Empty pass statements in adapters have debug logging explaining the fallback. register_tools no-op is documented as intentional design decision.
</done>
</task>

</tasks>

<verification>
1. `from aadap.services.execution import ExecutionService` succeeds
2. Adapter files have logger.debug calls for fallback cases
3. base.py register_tools docstring explains intentional no-op
4. execution.py error handlers include error_code in logs
</verification>

<success_criteria>
- execution.py catches specific exception types with error_code logging
- databricks_adapter.py _coerce_task_id has debug logging for invalid format
- fabric_adapter.py _coerce_task_id has debug logging for invalid format
- base.py register_tools documented as intentional no-op
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-exception-handling/01-03-SUMMARY.md`
</output>
