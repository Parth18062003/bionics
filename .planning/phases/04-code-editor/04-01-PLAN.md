---
phase: 04-code-editor
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - aadap/db/models.py
  - aadap/api/routes/artifacts.py
  - alembic/versions/004_add_artifact_version.py
autonomous: true
requirements: [EDIT-01, EDIT-03, EDIT-04]
user_setup: []

must_haves:
  truths:
    - "Artifact has version number that increments on save"
    - "User can retrieve any version of an artifact"
    - "User can compute diff between any two versions"
    - "User can save edited code as a new version"
  artifacts:
    - path: "aadap/db/models.py"
      provides: "Artifact model with version field"
      contains: "version.*Mapped\\[int\\]"
    - path: "aadap/api/routes/artifacts.py"
      provides: "Version management and diff API"
      exports: ["GET versions", "GET diff", "POST save"]
    - path: "alembic/versions/004_add_artifact_version.py"
      provides: "Migration for version field"
  key_links:
    - from: "aadap/api/routes/artifacts.py"
      to: "Artifact model"
      via: "SQLAlchemy queries"
      pattern: "select\\(Artifact\\)"
---

<objective>
Add version tracking to artifacts and create API endpoints for version management, diff computation, and saving edited code.

Purpose: Enable users to track changes to generated code and compare versions before deployment.
Output: Database migration, version endpoints, diff endpoint, save endpoint.
</objective>

<execution_context>
@C:/Users/parth/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/parth/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-code-editor/04-CONTEXT.md

# Existing code
@aadap/db/models.py
@aadap/api/routes/artifacts.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add version tracking to Artifact model</name>
  <files>
    aadap/db/models.py
    alembic/versions/004_add_artifact_version.py
  </files>
  <action>
    Add version tracking to the Artifact model:
    
    1. Add `version: Mapped[int]` field to Artifact model (default=1, not nullable)
    2. Add `parent_id: Mapped[uuid.UUID | None]` field to track lineage (self-referencing FK to artifacts.id, nullable)
    3. Add composite index on (task_id, version) for efficient version queries
    4. Add `version` to existing index or create new index
    
    Migration (004_add_artifact_version.py):
    - Add `version` column with default 1 to existing rows
    - Add `parent_id` column as nullable UUID
    - Add FK constraint for parent_id -> artifacts.id
    - Add composite index (task_id, version)
    
    Follow existing migration patterns from 003_add_infra_models.py.
  </action>
  <verify>
    `alembic upgrade head` succeeds
    `python -c "from aadap.db.models import Artifact; print(Artifact.version)"` runs without error
  </verify>
  <done>
    Artifact model has version and parent_id fields
    Migration applies successfully
    Existing artifacts have version=1
  </done>
</task>

<task type="auto">
  <name>Task 2: Create artifact version API endpoints</name>
  <files>
    aadap/api/routes/artifacts.py
  </files>
  <action>
    Add version management endpoints to artifacts.py:
    
    1. **GET /api/v1/tasks/{task_id}/artifacts/{artifact_id}/versions**
       - Return list of all versions for this artifact lineage
       - Query: artifacts with same root parent OR same artifact if no children
       - Response: `ArtifactVersionSummary[]` with id, version, created_at, content_hash
    
    2. **GET /api/v1/tasks/{task_id}/artifacts/{artifact_id}/versions/{version}**
       - Return specific version of artifact
       - Response: `ArtifactDetailResponse` (existing schema)
    
    3. **POST /api/v1/tasks/{task_id}/artifacts/{artifact_id}/versions**
       - Save edited content as new version
       - Request body: `{ content: string, edit_message?: string }`
       - Create new Artifact with version = max(version) + 1, parent_id = current artifact id
       - Copy name, artifact_type, task_id from parent
       - Compute content_hash for new content
       - Return new `ArtifactDetailResponse`
    
    Add Pydantic schemas:
    - `ArtifactVersionSummary`: id, version, created_at, content_hash, edit_message
    - `ArtifactVersionCreateRequest`: content, edit_message (optional)
    
    Follow existing patterns in artifacts.py (error handling, logging, type hints).
  </action>
  <verify>
    `python -c "from aadap.api.routes.artifacts import router; print(len([r for r in router.routes]))"` shows 5+ routes
    FastAPI app starts without errors
  </verify>
  <done>
    GET versions endpoint returns version history
    GET specific version returns that version's content
    POST versions creates new artifact version with incremented version number
  </done>
</task>

<task type="auto">
  <name>Task 3: Create diff API endpoint</name>
  <files>
    aadap/api/routes/artifacts.py
  </files>
  <action>
    Add diff computation endpoint:
    
    **GET /api/v1/tasks/{task_id}/artifacts/{artifact_id}/diff**
    Query params:
    - `from_version`: int (required) - base version for comparison
    - `to_version`: int (required) - version to compare against
    
    Response:
    ```python
    class DiffLine(BaseModel):
        old_line: int | None  # Line number in original (None if added)
        new_line: int | None  # Line number in new (None if removed)
        content: str
        type: str  # "unchanged" | "added" | "removed"
    
    class DiffResponse(BaseModel):
        from_version: int
        to_version: int
        from_content: str | None  # Full original content
        to_content: str | None    # Full new content
        diff: list[DiffLine]      # Unified diff format
        stats: dict[str, int]     # {"added": N, "removed": N, "unchanged": N}
    ```
    
    Implementation:
    - Fetch both artifact versions
    - Use Python's `difflib.unified_diff` to compute differences
    - Parse diff output into structured line-by-line format
    - Include full content for side-by-side rendering
    
    Handle edge cases:
    - Version not found → 404
    - Same version → return empty diff with stats all 0
    - One version has no content → treat as empty string
  </action>
  <verify>
    `curl "http://localhost:8000/api/v1/tasks/{task_id}/artifacts/{artifact_id}/diff?from_version=1&to_version=2"` returns valid DiffResponse
  </verify>
  <done>
    Diff endpoint returns structured comparison between versions
    Stats accurately count added/removed/unchanged lines
    Works with empty content and missing versions
  </done>
</task>

</tasks>

<verification>
1. Run `alembic upgrade head` - migration succeeds
2. Run `uvicorn aadap.main:app` - app starts without errors
3. Test API endpoints with curl:
   - GET versions list
   - GET specific version
   - POST new version
   - GET diff between versions
</verification>

<success_criteria>
- Artifact model has version and parent_id fields
- Migration applies cleanly
- API provides version listing, retrieval, creation, and diff computation
- All endpoints return proper error responses for invalid inputs
</success_criteria>

<output>
After completion, create `.planning/phases/04-code-editor/04-01-SUMMARY.md`
</output>
